Subject: [PATCH] xstate
---
Index: src/registry.mcp.client.xstate.ts
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/registry.mcp.client.xstate.ts b/src/registry.mcp.client.xstate.ts
new file mode 100644
--- /dev/null	(date 1750320282126)
+++ b/src/registry.mcp.client.xstate.ts	(date 1750320282126)
@@ -0,0 +1,735 @@
+import {
+  enqueueActions,
+  setup,
+  assign,
+  ActorLogic,
+  Values,
+  emit,
+  spawnChild,
+  fromPromise,
+  fromCallback,
+  ActorRefFromLogic,
+} from "xstate";
+import {
+  auth,
+  OAuthClientProvider,
+} from "@modelcontextprotocol/sdk/client/auth.js";
+import { Client } from "@modelcontextprotocol/sdk/client/index.js";
+import type { SSEClientTransportOptions } from "@modelcontextprotocol/sdk/client/sse.js";
+import type {
+  RequestHandlerExtra,
+  RequestOptions,
+} from "@modelcontextprotocol/sdk/shared/protocol.js";
+import { Transport } from "@modelcontextprotocol/sdk/shared/transport.js";
+import {
+  CallToolRequest,
+  CallToolResult,
+  ResourceUpdatedNotificationSchema,
+  type CallToolRequestSchema,
+  type CallToolResultSchema,
+  type CompatibilityCallToolResultSchema,
+  type CompleteRequest,
+  type GetPromptRequest,
+  type Prompt,
+  type ReadResourceRequest,
+  type Request,
+  type Resource,
+  type ResourceTemplate,
+  type ResultSchema,
+  type Tool,
+} from "@modelcontextprotocol/sdk/types.js";
+import { jsonSchema, type ToolSet } from "ai";
+import * as Y from "yjs";
+import mcpClientMachine, { MCPClient } from "./mcp.client.xstate.js";
+import { yMapIterate } from "@cxai/stream";
+import { Server } from "@modelcontextprotocol/sdk/server/index.js";
+import { env, version } from "node:process";
+import { AuthInfo } from "@modelcontextprotocol/sdk/server/auth/types.js";
+import { StreamableHTTPClientTransport } from "@modelcontextprotocol/sdk/client/streamableHttp.js";
+import { ListConnectionsResultSchema } from "./registry.mcp.server";
+import { z } from "zod";
+import EventEmitter from "node:events";
+import { createActor } from "xstate";
+
+type NamespacedSource = {
+  name: string;
+  source: {
+    name: string;
+    url: string;
+    server: string;
+  };
+};
+
+type NamespacedData = {
+  tools: (Tool & NamespacedSource)[];
+  prompts: (Prompt & NamespacedSource)[];
+  resources: (Resource & NamespacedSource)[];
+  resourceTemplates: (ResourceTemplate & NamespacedSource)[];
+};
+
+export type ServerConfig = {
+  id: string;
+  url: string;
+  name?: string;
+  version?: string;
+  status?: string;
+  error?: {
+    message: string;
+    stack?: string;
+    code?: string;
+  };
+};
+const clientManagerSetup = setup({
+  types: {} as {
+    context: ClientManager.Context;
+    events: ClientManager.Event;
+    input: ClientManager.Input;
+    emitted: ClientManager.EmittedEvent;
+    actors: {
+      mcpClient: typeof mcpClientMachine;
+      connectionManager: ActorLogic<any, any, any, any, any>;
+      registryUpdater: ActorLogic<any, any, any, any, any>;
+      cacheCleaner: ActorLogic<any, any, any, any, any>;
+    };
+  },
+  actors: {
+    mcpClient: mcpClientMachine,
+    connectionManager: fromCallback(
+      ({
+        sendBack,
+        input,
+      }: {
+        sendBack: (event: any) => void;
+        input: ClientManager.ConnectionManagerInput;
+      }) => {
+        const { session, store } = input;
+
+        // Observe store changes and manage connections
+        const observer = (event: Y.YMapEvent<ServerConfig>) => {
+          for (const [key] of event.changes.keys.entries()) {
+            const config = store.get(key);
+            if (config && !config.status) {
+              sendBack({
+                type: "connect",
+                ...config,
+                id: key,
+              });
+            }
+          }
+        };
+
+        store.observe(observer);
+
+        // Return cleanup function
+        return () => {
+          store.unobserve(observer);
+        };
+      }
+    ),
+    registryUpdater: fromCallback<MCPClient.Updates.ResourceData,ClientManager.RegistryUpdaterInput,MCPClient.Event>(
+      ({
+        sendBack,
+        input,
+        self
+      } ) => {
+        const { registry, actors } = input;
+
+        const updateRegistry = async ({ resources, client }: { resources: Resource[], client: Client }) => {
+          try {
+            console.log("updateFromRegistry", registry.getSnapshot().context.url?.toString() , resources?.length);
+            const serverResources = resources.filter((resource) =>
+              resource.uri.includes("urn:mcp:server/")
+            );
+            client
+            
+            for (const resource of serverResources) {
+              try {
+                const { uri, name } = resource;
+                const serverResponse = await client.readResource({
+                  uri,
+                });
+
+                if (serverResponse.contents?.[0]) {
+                  const serverData = JSON.parse(
+                    serverResponse.contents[0].text as string
+                  );
+                  console.log("add connection", serverData);
+                  const existingConnection = actors[serverData.id]?.getSnapshot()?.context; 
+                  if (serverData.id && serverData.url && !existingConnection?.url === serverData.url) {
+                    sendBack({
+                      type: "connect",
+                      config: {
+                        id: serverData.id,
+                        url: serverData.url,
+                        name: serverData.name || name,
+                        version: serverData.version,
+                      },
+                    });
+                  }
+                }
+              } catch (error) {
+                console.error(
+                  `Error processing server resource ${resource.uri}:`,
+                  error
+                );
+              }
+            }
+          } catch (error) {
+            console.error("Error updating from registry:", error);
+          }
+        };
+
+        const snapshot = registry.getSnapshot(); 
+        if(snapshot.context.client ){
+          // Initial update
+          // updateRegistry({ resources: snapshot.context.resources, client: snapshot.context.client });
+          for (const [id, resource] of Object.entries(snapshot.context.resourceData)) {
+            const {contents} = resource;
+            const {mcpActors} = self._parent?.getSnapshot()?.context; 
+            if ( !mcpActors[id]) {
+              console.log("connect", id);
+              sendBack({
+                type: "connect", 
+                id,
+                ...contents[0]
+              });
+            }
+          }
+        }
+
+        registry.on("@updates.resources.data", (e) => {
+           console.log("@updates.resources.data", e);
+           const { name, contents } = e as MCPClient.Updates.ResourceDataUpdate;
+           const {mcpActors} = self._parent?.getSnapshot()?.context; 
+           if ( !mcpActors[name]) {
+            console.log("connect", name);
+            sendBack({
+              type: "connect", 
+               ...contents[0]
+            });
+          }
+        }); 
+      }
+       
+      
+    
+    ),
+    cacheCleaner: fromCallback(
+      ({
+        sendBack,
+        input,
+      }: {
+        sendBack: (event: any) => void;
+        input: ClientManager.CacheCleanerInput;
+      }) => {
+        const { clientCache, CACHE_TTL } = input;
+
+        const cleanup = () => {
+          const now = Date.now();
+          const expiredKeys: string[] = [];
+
+          for (const [key, cached] of clientCache.entries()) {
+            if (now - cached.lastUsed > CACHE_TTL) {
+              expiredKeys.push(key);
+            }
+          }
+
+          if (expiredKeys.length > 0) {
+            sendBack({
+              type: "cleanup",
+              expiredKeys,
+            });
+          }
+        };
+
+        // Run cleanup every minute
+        const interval = setInterval(cleanup, 60 * 1000);
+
+        return () => {
+          clearInterval(interval);
+        };
+      }
+    ),
+  },
+  actions: {
+    emit: emit((_, e: ClientManager.EmittedEvent) => e),
+  },
+});
+
+const clientManagerMachine = clientManagerSetup.createMachine({
+  id: "@manager/client",
+  initial: "init",
+  context: ({ input }) => ({
+    session: input.session,
+    store: input.store,
+    mcpActors: {} as Record<string, any>,
+    tools: [] as NamespacedData["tools"],
+    prompts: [] as NamespacedData["prompts"],
+    resources: [] as NamespacedData["resources"],
+    resourceTemplates: [] as NamespacedData["resourceTemplates"],
+    clientCache: new Map<
+      string,
+      {
+        client: Client;
+        transport: StreamableHTTPClientTransport;
+        lastUsed: number;
+      }
+    >(),
+    CACHE_TTL: 5 * 60 * 1000, // 5 minutes
+    connected: new EventEmitter(),
+    pendingConnection: undefined,
+  }),
+  states: {
+    init: {
+        entry:  enqueueActions(({ context, enqueue ,self}) => {
+            const id= self.id;
+            const url= new URL(`${env.MCP_REGISTRY_URL!}/${id}`);
+            enqueue.assign({
+                mcpActors: ({ context: { mcpActors, session }, spawn }) => ({
+                  ["@registry"]: spawn("mcpClient", {
+                    systemId: `@regisrty:${session?.id}`,
+                    syncSnapshot: true,
+                    input: {
+                      url: url,
+                      options: {
+                        info: {
+                          name: id,
+                          version: version || "1.0.0",
+                        },
+                        transport: () =>
+                          new StreamableHTTPClientTransport(url, {
+                            requestInit: context.session.auth?.token
+                              ? {
+                                  headers: {
+                                    Authorization: `Bearer ${context.session.auth.token}`,
+                                  },
+                                }
+                              : undefined,
+                          }),
+                      },
+                    },
+                  }),
+                  ...mcpActors,
+                })
+            })
+        }),
+        invoke: {
+          src:  fromPromise(async ({ input }) => {
+            const { registry } = input;
+            return new Promise((resolve, reject) => {
+            const snapshot = registry.getSnapshot();
+            if(snapshot.context.client && snapshot.matches("ready")){
+              return snapshot.context;
+            }
+                // Subscribe to resource changes for updates
+            const subscription = registry.subscribe((state) => {
+              if(state.matches("ready") ){
+                resolve(state.context);
+              }
+            });   
+            return () => {
+              subscription.unsubscribe();
+            };
+          });
+          }),
+          input: ({ context }) => ({
+            registry: context.mcpActors["@registry"],
+          }),
+          onDone: {
+            target: "running",
+          },
+          onError: {
+            target: "error",
+            actions: assign({
+              error: ({ event }) => event.error as Error,
+            }),
+          },
+        },
+     
+    
+    },
+
+    running: {
+      type: "parallel",
+      states: {
+        connecting: {
+          entry: enqueueActions(({ context, enqueue }) => {
+            if (context.pendingConnection) {
+              const { url, name, version, id } = context.pendingConnection;
+              enqueue.emit({
+                type: `@connection.connecting.${id}`,
+                timestamp: Date.now(),
+                url,
+                name,
+                version,
+                id,
+                session: context.session,
+              });
+              enqueue.assign({
+                mcpActors: ({ context: { mcpActors, session }, spawn }) => ({
+                  [id]: spawn("mcpClient", {
+                    systemId: `${id}:${session?.id}`,
+                    syncSnapshot: true,
+                    input: {
+                      url: new URL(url),
+                      options: {
+                        info: {
+                          name: name || id,
+                          version: version || "1.0.0",
+                        },
+                        transport: () =>
+                          new StreamableHTTPClientTransport(new URL(url), {
+                            requestInit: context.session.auth?.token
+                              ? {
+                                  headers: {
+                                    Authorization: `Bearer ${context.session.auth.token}`,
+                                  },
+                                }
+                              : undefined,
+                          }),
+                      },
+                    },
+                  }),
+                  ...mcpActors,
+                }),
+              });
+              enqueue(({ context: { mcpActors }, event }) => {
+                const actor = mcpActors[id];
+                if (actor) {
+                  actor.subscribe((state) => {
+                    // Handle status changes
+                    if (state.matches("connected")) {
+                      enqueue.emit({
+                        type: `@connection.connected.${id}`,
+                        timestamp: Date.now(),
+                        session: context.session,
+                      });
+                    } else if (state.matches("disconnected")) {
+                      enqueue.emit({
+                        type: `@connection.disconnected.${id}`,
+                        timestamp: Date.now(),
+                      });
+                    }
+                  });
+                }
+              });
+              // enqueue.spawnChild('mcpClient',{
+              //   id:  id,
+              //   systemId: `${id}:${context.session?.id}`,
+              //   syncSnapshot: true,
+              //   input: ({ context }) => ({
+              //     url: new URL(url),
+              //     options: {
+              //       info: {
+              //         name: name || id,
+              //         version: version || "1.0.0",
+              //       },
+              //       transport: () =>
+              //         new StreamableHTTPClientTransport(new URL(url), {
+              //           requestInit: context.session.auth?.token
+              //             ? {
+              //                 headers: {
+              //                   Authorization: `Bearer ${context.session.auth.token}`,
+              //                 },
+              //               }
+              //             : undefined,
+              //         })
+              //     },
+              //   }),
+              // })
+            }
+          }),
+          on: {
+            "@updates.tools": {
+              actions: [
+                assign({
+                  tools: ({ context, event }) =>
+                    getNamespacedData(context.mcpActors, "tools"),
+                }),
+                {
+                  type: "emit",
+                  params: ({ event }) => event,
+                },
+              ],
+            },
+          },
+        },
+        managing: {
+          invoke: [
+            {
+              src: "connectionManager",
+              input: ({ context }) => ({
+                session: context.session,
+                store: context.store,
+              }),
+            },
+            {
+              src: "registryUpdater",
+              input: ({ context: { mcpActors } }) => ({
+                registry: mcpActors["@registry"],
+                actors: mcpActors,
+              }),
+            },
+            {
+              src: "cacheCleaner",
+              input: ({ context }) => ({
+                clientCache: context.clientCache,
+                CACHE_TTL: context.CACHE_TTL,
+              }),
+            },
+          ],
+          on: {
+            cleanup: {
+              actions: [
+                assign({
+                  clientCache: ({ context, event }) => {
+                    const cleanupEvent = event as {
+                      type: "cleanup";
+                      expiredKeys: string[];
+                    };
+                    for (const key of cleanupEvent.expiredKeys) {
+                      const cached = context.clientCache.get(key);
+                      if (cached) {
+                        try {
+                          cached.client.close();
+                          cached.transport.close();
+                        } catch (error) {
+                          console.error(
+                            `Error closing cached client ${key}:`,
+                            error
+                          );
+                        }
+                        context.clientCache.delete(key);
+                      }
+                    }
+                    return context.clientCache;
+                  },
+                })
+              ],
+            },
+
+            disconnect: {
+              target: "disconnecting",
+            },
+            connect: {
+              target: "connecting",
+              actions: assign({
+                pendingConnection: ({ event }) => event,
+              }),
+            },
+          },
+        },
+        disconnecting: {
+          invoke: {
+            src: fromPromise(
+              async ({ input }: { input: { actors: Record<string, any> } }) => {
+                await Promise.all(
+                  Object.values(input.actors).map(async (actor) => {
+                    actor.send({ type: "cleanup" });
+                  })
+                );
+              }
+            ),
+            input: ({ context }) => ({ actors: context.mcpActors }),
+            onDone: {
+              target: "done",
+            },
+            onError: {
+              target: "done",
+            },
+          },
+        },
+        done: {
+          type: "final",
+          output: ({ context }) => context,
+        },
+      },
+    },
+    error: {
+      type: "final",
+      output: ({ context }) => context,
+      on: {
+        retry: {
+          target: "init",
+        },
+      },
+    },
+  },
+});
+// Helper functions
+export function getNamespacedData<T extends keyof NamespacedData>(
+  mcpActors: Record<string, any>,
+  type: T
+): NamespacedData[T] {
+  const sets = Object.entries(mcpActors).map(([name, actor]) => {
+    const snapshot = actor.getSnapshot();
+    return { name, data: snapshot.context[type] };
+  });
+
+  const namespacedData = sets.flatMap(({ name: server, data }) => {
+    if (!data || !Array.isArray(data)) {
+      console.warn(`Data for ${type} in client ${server} is not an array`);
+      return [];
+    }
+
+    try {
+      return data.map((resource: any) => {
+        const { name, uri, uriTemplate, ...item } = resource;
+        let resourceUri: string | undefined = undefined;
+        if (typeof uri === "string") {
+          resourceUri = uri;
+        } else if (typeof uriTemplate === "string") {
+          resourceUri = uriTemplate;
+        }
+        return {
+          ...item,
+          name: `${server}:${name}`,
+          uri: resourceUri ? `${server}:${resourceUri}` : undefined,
+          source: {
+            uri: resourceUri,
+            name,
+            server,
+          },
+        };
+      });
+    } catch (error) {
+      console.error(`Error getting ${type} data from client ${server}:`, error);
+      return [];
+    }
+  });
+
+  return namespacedData as NamespacedData[T];
+}
+
+export default clientManagerMachine;
+
+type Optional<T> = {
+  [K in keyof T]?: T[K];
+};
+
+export namespace ClientManager {
+  export type ConnectionManagerInput = {
+    session: {
+      store: Y.Map<ServerConfig>;
+      auth: AuthInfo;
+      session?: string;
+      id?: string;
+      name?: string;
+      version?: string;
+    };
+    store: Y.Map<ServerConfig>;
+  };
+
+  export type RegistryUpdaterInput = {
+    registry: ActorRefFromLogic<typeof mcpClientMachine>
+    actors: Record<string, ActorRefFromLogic<typeof mcpClientMachine>>
+  };
+
+  export type CacheCleanerInput = {
+    clientCache: Map<
+      string,
+      {
+        client: Client;
+        transport: StreamableHTTPClientTransport;
+        lastUsed: number;
+      }
+    >;
+    CACHE_TTL: number;
+  };
+
+  export type ConnectInput = {
+    config: ServerConfig;
+    session: {
+      store: Y.Map<ServerConfig>;
+      auth: AuthInfo;
+      session?: string;
+      id?: string;
+      name?: string;
+      version?: string;
+    };
+  };
+
+  export type Input = {
+    session: {
+      store: Y.Map<ServerConfig>;
+      auth: AuthInfo;
+      session?: string;
+      id?: string;
+      name?: string;
+      version?: string;
+    };
+    store: Y.Map<ServerConfig>;
+  };
+
+  export type Context = {
+    session: {
+      store: Y.Map<ServerConfig>;
+      auth: AuthInfo;
+      session?: string;
+      id?: string;
+      name?: string;
+      version?: string;
+    };
+    error?: Error;
+    store: Y.Map<ServerConfig>;
+    mcpActors: Record<string, any>;
+    tools: NamespacedData["tools"];
+    prompts: NamespacedData["prompts"];
+    resources: NamespacedData["resources"];
+    resourceTemplates: NamespacedData["resourceTemplates"];
+    clientCache: Map<
+      string,
+      {
+        client: Client;
+        transport: StreamableHTTPClientTransport;
+        lastUsed: number;
+      }
+    >;
+    CACHE_TTL: number;
+    connected: EventEmitter;
+    pendingConnection?: ServerConfig;
+  };
+
+  export type EmittedEvent = MCPClient.Event | Connection.Event;
+
+  export type Event =
+    | {
+        type: "cleanup";
+        expiredKeys: string[];
+      }
+    | ({
+        type: "connect";
+        session: Context["session"];
+      } & ServerConfig)
+    | ({
+        type: "disconnect";
+        id: string;
+      } & ServerConfig)
+    | MCPClient.Event;
+}
+
+export namespace Connection {
+  export type Event =
+    | {
+        type: "@connection.new";
+        connection: MCPClient.Context;
+      }
+    | ({
+        type: `@connection.connecting.${string}`;
+        timestamp: number;
+        session: ClientManager.Context["session"];
+      } & ServerConfig)
+    | ({
+        type: `@connection.connected.${string}`;
+        timestamp: number;
+        session: ClientManager.Context["session"];
+      } & ServerConfig)
+    | ({
+        type: `@connection.failed.${string}`;
+        timestamp: number;
+      } & ServerConfig)
+    | ({
+        Ã¥type: `@connection.disconnected.${string}`;
+        timestamp: number;
+      } & ServerConfig);
+}
Index: src/mcp.client.xstate.ts
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/mcp.client.xstate.ts b/src/mcp.client.xstate.ts
new file mode 100644
--- /dev/null	(date 1750321210213)
+++ b/src/mcp.client.xstate.ts	(date 1750321210213)
@@ -0,0 +1,709 @@
+import {
+  enqueueActions,
+  setup,
+  assign,
+  ActorLogic,
+  Values,
+  emit,
+  spawnChild,
+  fromPromise,
+  fromCallback,
+  sendTo,
+  raise,
+} from "xstate";
+import {
+  ToolListChangedNotificationSchema,
+  type ClientCapabilities,
+  type Resource,
+  type Tool,
+  type Prompt,
+  ResourceListChangedNotificationSchema,
+  PromptListChangedNotificationSchema,
+  type ListToolsResult,
+  type ListResourcesResult,
+  type ListPromptsResult,
+  type ServerCapabilities,
+  type ResourceTemplate,
+  type ListResourceTemplatesResult,
+  type Notification,
+} from "@modelcontextprotocol/sdk/types.js";
+import { Client } from "@modelcontextprotocol/sdk/client/index.js";
+import {
+  OAuthClientProvider,
+  UnauthorizedError,
+} from "@modelcontextprotocol/sdk/client/auth.js";
+import { StreamableHTTPClientTransport } from "@modelcontextprotocol/sdk/client/streamableHttp.js";
+import { SSEClientTransport } from "@modelcontextprotocol/sdk/client/sse.js";
+
+export type TransportFactory = () =>
+  | StreamableHTTPClientTransport
+  | SSEClientTransport;
+
+
+
+  const mcpClientSetup = setup({
+    types: {} as {
+      context: MCPClient.Context;
+      events: MCPClient.Event;
+      input: Optional<MCPClient.Input>;
+      actors: {
+        connection: ActorLogic<any, any, any, any, any>;
+        discovery: ActorLogic<any, any, any, any, any>;
+        notificationHandler: ActorLogic<any, any, any, any, any>;
+      };
+    },
+    actors: {
+      connection: fromPromise(
+        async ({ input }: { input: MCPClient.ConnectionInput }) => {
+          const { url, options } = input;
+          const {
+            info,
+            client: clientOptions,
+            transport: transportFactory,
+            ...transportOptions
+          } = options;
+          console.log("connecting to", url.toString());
+
+          const transport = transportFactory
+            ? transportFactory()
+            : new StreamableHTTPClientTransport(url, transportOptions);
+          const client = new Client(info, clientOptions);
+          try {
+            await client.connect(transport);
+            await client.ping();
+            return {
+              client,
+              transport,
+              serverCapabilities: await client.getServerCapabilities(),
+            };
+          } catch (error: any) {
+            if (error instanceof UnauthorizedError) {
+              throw new Error("Authentication required");
+            }
+            throw error;
+          }
+        }
+      ),
+      discovery: fromPromise(
+        async ({ input }: { input: MCPClient.DiscoveryInput }) => {
+          const { client, serverCapabilities } = input;
+
+          const [instructions, tools, resources, prompts, resourceTemplates] =
+            await Promise.all([
+              client.getInstructions(),
+              fetchTools(client),
+              fetchResources(client),
+              fetchPrompts(client),
+              fetchResourceTemplates(client),
+            ]);
+
+          return {
+            instructions,
+            tools,
+            resources,
+            prompts,
+            resourceTemplates,
+          };
+        }
+      ),
+      resourceDataHandler: fromCallback<MCPClient.Event,MCPClient.ResourceDataHandlerInput,MCPClient.Updates.ResourceData>(({
+        input,
+        receive,
+        sendBack
+      })=>{
+        const { client } = input;
+        receive(async (event)=>{
+            if(event.type === "read-resource"){
+                const { uri, name, mimeType } = event;
+                try{
+                const serverResponse = await client.readResource({ 
+                    uri,
+                })
+                if(mimeType==="application/json"){
+                    sendBack({
+                      type: "@updates.resources.data",
+                      name: name,
+                      mimeType:"application/json",
+                      contents: serverResponse.contents.map((content)=>content.text as string).filter(Boolean).map(e=>JSON.parse(e)),
+                    });
+                }
+                else if(mimeType==="text/plain"){
+                  sendBack({
+                    type: "@updates.resources.data",
+                    name: name,
+                    mimeType:"text/plain",
+                    contents: serverResponse.contents.map((content)=>content.text),
+                  });
+                }
+                else{
+                  sendBack({
+                    type: "@updates.resources.data",
+                    name: name,
+                    mimeType:mimeType,
+                    contents: serverResponse.contents,
+                  });
+                }
+              }
+              catch(error){
+                console.error("error reading resource: %s",error);
+                sendBack({
+                  type: "reconnect",
+                });
+              }
+            }
+          })
+        }
+      ),
+        
+      notificationHandler: fromCallback(
+        ({
+          sendBack,
+          input,
+        }: {
+          sendBack: (event: MCPClient.Updates.Event) => void;
+          input: MCPClient.NotificationHandlerInput;
+        }) => {
+          const { client, serverCapabilities } = input;
+          const { resources, prompts, resourceTemplates, tools } = input;
+          console.log("first init", "\nresources:", resources.map(r=>r.name), "\nprompts:", prompts.map(p=>p.name), "\nresourceTemplates:", resourceTemplates.map(r=>r.name), "\ntools:", tools.map(t=>t.name));
+            tools.length && sendBack({
+              type: "@updates.tools",
+              tools,
+            });
+            resources.length && sendBack({
+              type: "@updates.resources",
+              resources,
+            });
+            prompts.length && sendBack({
+              type: "@updates.prompts",
+              prompts,
+            });
+            resourceTemplates.length && sendBack({
+              type: "@updates.resourceTemplates",
+              resourceTemplates,
+            });
+           
+          // Register notification handlers that send events back to parent
+          if (serverCapabilities?.tools?.listChanged !== false) {
+            client.setNotificationHandler(
+              ToolListChangedNotificationSchema,
+              async (_notification) => {
+                const tools = await fetchTools(client);
+                sendBack({
+                  type: "@updates.tools",
+                  tools,
+                });
+              }
+            );
+          }
+
+          if (serverCapabilities?.resources?.listChanged !== false) {
+            client.setNotificationHandler(
+              ResourceListChangedNotificationSchema,
+              async (_notification) => {
+                const resources = await fetchResources(client);
+                sendBack({
+                  type: "@updates.resources",
+                  resources,
+                });
+                const resourceTemplates = await fetchResourceTemplates(client);
+                sendBack({
+                  type: "@updates.resourceTemplates",
+                  resourceTemplates,    
+                });
+              }
+            );
+          } 
+          if (serverCapabilities?.prompts?.listChanged !== false) {
+            client.setNotificationHandler(
+              PromptListChangedNotificationSchema,
+              async (_notification) => {
+                const prompts = await fetchPrompts(client);
+                sendBack({
+                  type: "@updates.prompts",
+                  prompts,
+                });
+              }
+            );
+          }
+
+      
+        }
+      ),
+    },
+    actions: {
+      emit: emit((_, e: MCPClient.Event) => e),
+    },
+  });
+
+  const mcpClientMachine = mcpClientSetup.createMachine({
+    id: "@mcp/client",
+    initial: "connecting",
+    context: ({ input }) =>  ({
+      url: input.url!,
+      options: input.options!,
+      instructions: undefined as string | undefined,
+      tools: [] as Tool[],
+      prompts: [] as Prompt[],
+      resourceData: {} as Record<string, {contents:{text:string}[]}>,
+      resources: [] as Resource[],
+      resourceTemplates: [] as ResourceTemplate[],
+      serverCapabilities: undefined as ServerCapabilities | undefined,
+      error: undefined as MCPClient.Error | undefined,
+      client: undefined as Client | undefined,
+      transport: undefined as ReturnType<TransportFactory> | undefined,
+    }), 
+    states: {
+      connecting: {
+        invoke: {
+          src: "connection",
+          input: ({ context }) => ({
+            url: context.url,
+            options: context.options,
+          }),
+          onDone: {
+            target: "discovering",
+            actions: assign({
+              client: ({ event }) => event.output.client,
+              transport: ({ event }) => event.output.transport,
+              serverCapabilities: ({ event }) =>
+                event.output.serverCapabilities,
+            }),
+          },
+          onError: {
+            target: "failed",
+            actions: [
+              assign({
+                error: ({ event }) => ({
+                  message: (event as any).error?.message || "Unknown error",
+                  stack: (event as any).error?.stack || "",
+                  code: (event as any).error?.code || -1,
+                }),
+              })
+            ],
+          },
+        },
+      },
+      discovering: {
+        invoke: {
+          src: "discovery",
+          input: ({ context }) => ({
+            client: context.client!,
+            serverCapabilities: context.serverCapabilities!,
+          }),
+          onDone: {
+            target: "ready",
+            actions: [
+              assign({
+                instructions: ({ event }) => event.output.instructions,
+                tools: ({ event }) => event.output.tools,
+                resources: ({ event }) => event.output.resources,
+                prompts: ({ event }) => event.output.prompts,
+                resourceTemplates: ({ event }) =>
+                  event.output.resourceTemplates,
+              }),
+            ],
+          },
+          onError: {
+            target: "failed",
+            actions: [
+              assign({
+                error: ({ event }) => ({
+                  message: (event as any).error?.message || "Unknown error",
+                  stack: (event as any).error?.stack || "",
+                  code: (event as any).error?.code || -1,
+                }),
+              })
+            ],
+          },
+        },
+      },
+      ready: {
+        invoke: [{
+          src: "notificationHandler",
+          input: ({ context }) => ({
+            client: context.client!,
+            serverCapabilities: context.serverCapabilities!,
+            resources: context.resources,
+            prompts: context.prompts,
+            resourceTemplates: context.resourceTemplates,
+            tools: context.tools,
+          }),
+        },
+        {
+          src: "resourceDataHandler",
+          id:"@mcp/resource",
+          input: ({ context }) => ({
+            client: context.client!,
+          }),
+          onError:{
+            target: "failed",
+            actions: [
+              assign({
+                error: ({ event }) => ({
+                  message: (event as any).error?.message || "Unknown error",
+                  stack: (event as any).error?.stack || "",
+                  code: (event as any).error?.code || -1,   
+                }),
+              })
+            ],
+          },
+          
+        }],
+        on: {
+          reconnect: {
+            target: "connecting",
+            actions: assign({
+              error: undefined,
+            }),
+          },
+          cleanup: {
+            target: "cleaning",
+          },
+          "@updates.tools": {
+            actions: [
+              assign({
+                tools: ({ event }) => event.tools,
+              }),
+              {
+                type: "emit",
+                params: ({ event }) => event,
+              },
+            ],
+          },
+          "@updates.resources": {
+            actions: enqueueActions(({ event, enqueue, context}) => {
+            
+               const { resources } = event;
+               const {resourceData, resources:existingResources} = context;
+               enqueue. assign({
+                    resources: ({ event }) => event.resources,
+               })
+
+              for (const resource of event.resources) {
+                if(resourceData[resource.name]?.uri !== resource.uri){
+                  enqueue.sendTo("@mcp/resource", {
+                    type: "read-resource",
+                     ...resource,
+                  });
+                }
+              }
+      
+              for (const resource of resources) {
+                if(!existingResources.some(r=>r.uri === resource.uri)){
+                   enqueue.emit({
+                    type: "@updates.resource",
+                    ...resource,
+                   })
+                }
+            }
+            }),
+          },
+          "@updates.resources.data": {
+            actions: [
+              assign({
+                resourceData: ({ event, context:{resourceData} }) => {
+                  const { type,name,...data } = event as MCPClient.Updates.ResourceDataUpdate;
+                  return {
+                    ...resourceData,
+                    [name]: {
+                      name,
+                      ...data,
+                    }
+                  };
+                },
+              }),
+              {
+                type: "emit",
+                params: ({ event }) => event,
+              },
+            ],
+          },
+          "@updates.prompts": {
+            actions: [
+              assign({
+                prompts: ({ event }) => event.prompts,
+              }),
+              {
+                type: "emit",
+                params: ({ event }) => event,
+              },
+            ],
+          },
+        },
+      },
+      failed: {
+        entry: ({ context:{error} }) =>  console.warn("failed connection: ",error),
+        after:{
+            10_000: {
+               actions:raise({
+                type: "retry",
+               }),
+            }
+        },
+        on: {
+          retry: {
+            target: "connecting",
+            actions:[ assign({
+              error: undefined,
+              retries: ({ context:{retries} }) => retries + 1,
+            }),  ({ context:{retries} }) =>  console.log("retry connection:",retries)],
+          },
+        },
+      },
+      cleaning: {
+        invoke: {
+          src: fromPromise(
+            async ({
+              input,
+            }: {
+              input: { transport: ReturnType<TransportFactory> };
+            }) => {
+              await input.transport.close();
+            }
+          ),
+          input: ({ context }) => ({ transport: context.transport! }),
+          onDone: {
+            target: "done",
+          },
+          onError: {
+            target: "done",
+          },
+        },
+      },
+      done: {
+        type: "final",
+      },
+    },
+  });
+
+
+// export function fromMcpClient(
+//   url: URL,
+//   options: {
+//     info: ConstructorParameters<typeof Client>[0];
+//     client?: ConstructorParameters<typeof Client>[1];
+//     transport?: TransportFactory;
+//     oauthProvider?: OAuthClientProvider;
+//   }
+// ) {
+
+
+//   return mcpClientMachine;
+// }
+
+// Helper functions
+async function fetchTools(client: Client): Promise<Tool[]> {
+  let toolsAgg: Tool[] = [];
+  let toolsResult: ListToolsResult = { tools: [] };
+  do {
+    toolsResult = await client
+      .listTools({
+        cursor: toolsResult.nextCursor,
+      })
+      .catch(capabilityErrorHandler({ tools: [] }, "tools/list"));
+    toolsAgg = toolsAgg.concat(toolsResult.tools);
+  } while (toolsResult.nextCursor);
+  return toolsAgg;
+}
+
+async function fetchResources(client: Client): Promise<Resource[]> {
+  let resourcesAgg: Resource[] = [];
+  let resourcesResult: ListResourcesResult = { resources: [] };
+  do {
+    resourcesResult = await client
+      .listResources({
+        cursor: resourcesResult.nextCursor,
+      })
+      .catch(capabilityErrorHandler({ resources: [] }, "resources/list"));
+    resourcesAgg = resourcesAgg.concat(resourcesResult.resources);
+  } while (resourcesResult.nextCursor);
+  return resourcesAgg;
+}
+
+async function fetchPrompts(client: Client): Promise<Prompt[]> {
+  let promptsAgg: Prompt[] = [];
+  let promptsResult: ListPromptsResult = { prompts: [] };
+  do {
+    promptsResult = await client
+      .listPrompts({
+        cursor: promptsResult.nextCursor,
+      })
+      .catch(capabilityErrorHandler({ prompts: [] }, "prompts/list"));
+    promptsAgg = promptsAgg.concat(promptsResult.prompts);
+  } while (promptsResult.nextCursor);
+  return promptsAgg;
+}
+
+async function fetchResourceTemplates(
+  client: Client
+): Promise<ResourceTemplate[]> {
+  let templatesAgg: ResourceTemplate[] = [];
+  let templatesResult: ListResourceTemplatesResult = {
+    resourceTemplates: [],
+  };
+  do {
+    templatesResult = await client
+      .listResourceTemplates({
+        cursor: templatesResult.nextCursor,
+      })
+      .catch(
+        capabilityErrorHandler(
+          { resourceTemplates: [] },
+          "resources/templates/list"
+        )
+      );
+    templatesAgg = templatesAgg.concat(templatesResult.resourceTemplates);
+  } while (templatesResult.nextCursor);
+  return templatesAgg;
+}
+
+function capabilityErrorHandler<T>(empty: T, method: string) {
+  return (e: { code: number }) => {
+    if (e.code === -32601) {
+      console.error(
+        `The server advertised support for the capability ${
+          method.split("/")[0]
+        }, but returned "Method not found" for '${method}'.`
+      );
+      return empty;
+    }
+    throw e;
+  };
+}
+
+export default mcpClientMachine;
+
+type Optional<T> = {
+  [K in keyof T]?: T[K];
+};
+
+export namespace MCPClient {
+  export type ConnectionState =
+    | "connecting"
+    | "discovering"
+    | "ready"
+    | "failed"
+    | "cleaning";
+
+  export type Error = {
+    message: string;
+    stack: string;
+    code: number;
+  };
+
+  export type ConnectionInput = {
+    url: URL;
+    options: {
+      info: ConstructorParameters<typeof Client>[0];
+      client?: ConstructorParameters<typeof Client>[1];
+      transport?: TransportFactory;
+    };
+  };
+
+  export type DiscoveryInput = {
+    client: Client;
+    serverCapabilities: ServerCapabilities;
+  };
+
+  export type NotificationHandlerInput = {
+    client: Client;
+    serverCapabilities: ServerCapabilities;
+    resources: Resource[];
+    prompts: Prompt[];
+    resourceTemplates: ResourceTemplate[];
+    tools: Tool[];
+  };
+
+  export type ResourceDataHandlerInput = {
+    client: Client;
+  };
+  export type ResourceData = {
+    name: string;
+    uri: string;
+    mimeType: string;
+    contents: any[];
+  };
+
+  export namespace Updates {
+    export type Tools = {
+      type: "@updates.tools";
+      tools: Tool[];
+    };
+    export type ResourceUpdate = {
+      type: "@updates.resource"; 
+    } & Resource;
+    export type Resources = {
+      type: "@updates.resources";
+      resources: Resource[];
+    };
+    export type Prompts = {
+      type: "@updates.prompts";
+      prompts: Prompt[];
+    };
+    export type ResourceTemplates = {
+      type: "@updates.resourceTemplates";
+      resourceTemplates: ResourceTemplate[];
+    };
+    export type Notifications = {
+      type: "@updates.notifications";
+      notifications: Notification[];
+    };
+    export type ResourceDataUpdate = {
+      type: "@updates.resources.data";
+    } & ResourceData;
+
+    export type Event =
+      | Tools
+      | Resources
+      | Prompts
+      | ResourceTemplates
+      | Notifications
+      | ResourceDataUpdate
+      | ResourceUpdate;
+  }
+
+  export type Event = |{
+    type: "read-resource"; 
+  } & Resource
+    | {
+        type: "reconnect";
+      }
+    | {
+        type: "retry";
+      }
+    | {
+        type: "cleanup";
+      }
+    | Updates.Event;
+
+  export type Input = {
+    url: URL;
+    options?: {
+      info: ConstructorParameters<typeof Client>[0];
+      client?: ConstructorParameters<typeof Client>[1];
+      transport?: TransportFactory;
+    };
+  };
+
+  export type Context = {
+    url: URL;
+    options: {
+      info: ConstructorParameters<typeof Client>[0];
+      client?: ConstructorParameters<typeof Client>[1];
+      transport?: TransportFactory;
+    };
+    instructions: string | undefined;
+    tools: Tool[];
+    prompts: Prompt[];
+    resources: Resource[];
+    resourceData: Record<string, ResourceData>;
+    resourceTemplates: ResourceTemplate[];
+    serverCapabilities: ServerCapabilities | undefined;
+    error: Error | undefined;
+    client: Client | undefined;
+    transport: ReturnType<TransportFactory> | undefined;
+    retries: number;
+
+  };
+}
